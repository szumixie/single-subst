\documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\newcommand{\ra}{\rightarrow}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Ty}{\mathsf{Ty}}
\newcommand{\Tm}{\mathsf{Tm}}
\newcommand{\Con}{\mathsf{Con}}
\newcommand{\Sub}{\mathsf{Sub}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\ext}{\mathop{\triangleright}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\lam}{\mathsf{lam}}
\newcommand{\app}{\mathsf{app}}
\newcommand{\U}{\mathsf{U}}
\newcommand{\El}{\mathsf{El}}
\newcommand{\cd}{\mathsf{c}}
\newcommand{\blank}{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}} %from the book

\begin{document}

\title{Type theory in type theory with single substitutions}
\author{Ambrus Kaposi and Szumi Xie}
\date{\today}

\begin{abstract}
Type theory can be described as a generalised algebraic theory. This
automatically gives a notion of model and the existence of the syntax
as the initial model, which is a quotient inductive-inductive
type. Algebraic definitions of type theory include Ehrhard's
definition of model, categories with families (CwFs), contextual
categories, Awodey's natural models, C-systems, B-systems. With the
exception of B-systems, these notions are based on a parallel
substitution calculus where substitutions form a category. In this
paper we define a single substitution calculus (SSC) for type theory
and show that the SSC syntax and the CwF syntax are isomorphic for a
theory with dependent function space and a hierarchy of universes. SSC
only includes single substitutions and single weakenings, and eight
equations relating these: four equations describe how to substitute
variables, and there are four equations on types which are needed to
typecheck other equations. All the other equations are substitution
(naturality) rules or computation rules for different type
formers. SSC provides a simple, minimalistic alternative to parallel
substitution calculi or B-systems for defining type theory. SSC
relates to CwF as extensional combinatory calculus relates to lambda
calculus. All the results in this paper were formalised in Agda.
\end{abstract}

\maketitle

\section{Introduction}

What is type theory? Here we refer to type theory as a particular
formal system based on Martin-Löf's original definition
\cite{martinlof73predicative}, and not to the field studying type
systems (e.g.\ \cite{DBLP:books/daglib/0005958}). When answering this
question, we aim for simplicity and ease of understanding.

Type theory is a language which can be described as a second-order
generalised algebraic theory (SOGAT
\cite{DBLP:conf/fscd/KaposiX24}). Some properties of this description:
\begin{enumerate}
\item[(i)] It is an intrinsic presentation
  \cite{DBLP:conf/csl/AltenkirchR99,DBLP:conf/popl/AltenkirchK16} as
  opposed to extrinsic. That is, we only consider well-formed,
  well-scoped and well-typed abstract syntax trees, there are no
  meaningless terms.
\item[(ii)] Terms are quotiented by the conversion relation.
\item[(iii)] Every operation is stable under substitution.
\end{enumerate}
For example, type theory with $\Pi$ types and universes {\`a} la
Coquand \cite{coquandUniverse} is specified by the following SOGAT.
\begin{alignat*}{10}
  & \Ty && : \N\ra\Set \\
  & \Tm && : \Ty\,i\ra\Set \\
  & \Pi && : (A:\Ty\,i)\ra(\Tm\,A\ra\Ty\,i)\ra\Ty\,i \\
  & \app && : \Tm\,(\Pi\,A\,B)\cong((a:\Tm\,A)\ra\,\Tm\,(B\,a)): \lam \\
  & \U && : (i:\N)\ra\Ty\,(1+i) \\
  & \El && : \Tm\,(\U\,i)\cong\Ty\,i : \cd
\end{alignat*}
We use implicit arguments, e.g.\ $\Tm$ takes the $i:\N$ implicitly,
and $\app$ takes $i$, $A$ and $B$ implicitly. $f : X \cong Y : g$
denotes an isomorphism, that is, $f : X\ra Y$, $g:Y\ra X$ with
$g\,(f\,x) = x$ and $f\,(g\,y) = y$ for all $x$, $y$. Note that $\Pi$
and $\lam$ are second-order functions. We say that $\Pi$ binds a
$\Tm$-variable in its second $\Ty$-argument. Every binder is
represented by a second-order function, and as a result, we don't need
to talk about contexts and substitutions when describing the theory:
we re-use the binding features of the metatheory to describe those of
our object theory (this technique is also called higher-order abstract
syntax \cite{DBLP:conf/lics/Hofmann99} or logical framework
\cite{DBLP:journals/jacm/HarperHP93,10.1007/978-3-642-14203-1_2}). There
is no good notion of homomorphism between second-order models, thus
the semantics of a SOGAT is given by a first order generalised
algebraic theory (GAT \cite{DBLP:journals/apal/Cartmell86}). GATs are
generalisations of single-sorted algebraic theories (such as monoids,
groups) to multiple sorts where later sorts can be indexed over
previous sorts, and the usual results from universal algebra (e.g.\ a
category of models with finite limits and initial object, free and
co-free models) carry over to GATs
\cite{andras,DBLP:phd/hal/Moeneclaey22}. An example of a GAT is the
theory of categories where there is a sort for objects and a sort for
morphisms double-indexed over objects.

Kaposi and Xie \cite{DBLP:conf/fscd/KaposiX24} present two different
first order semantics for any SOGAT: one based on parallel
substitutions, and one based on single substitutions.

In the parallel semantics, the GAT always starts with a category with
a terminal object, objects of the category are called contexts,
morphisms are substitutions. Every sort and operation of the SOGAT
gives rise to an operation in the GAT which is indexed by
contexts. The sorts moreoever come with functorial instantiation
(sometimes called substitution) operations, and all the operations are
natural with respect to instantiation. For those sorts which are bound
by an operation, we have context extension, meaning that contexts can
carry variables of that sort (in other words, the sort is given by a
locally representable presheaf). The parallel semantics of the GAT
\begin{alignat*}{10}
  & \Ty && : \Set \\
  & \Tm && : \Ty \ra\Set 
\end{alignat*}
is the GAT of categories with families (CwFs
\cite{DBLP:conf/types/Dybjer95,Castellan2021}). To define the notion
of model of a language (given by a SOGAT) is to take its parallel
substitution semantics, which is a GAT, and that induces a notion of
model. The syntax of the language is the initial model, which exists
for every GAT \cite{DBLP:journals/pacmpl/KaposiKA19}. This is an
intrinsic definition of syntax (only well-typed terms), which is
quotiented by the equations in the SOGAT, which describe conversion
for the language.

The single substitution semantics is an alternative GAT xxx





In a type-theoretic metatheory,
the initial model of a GAT is a quotient inductive-inductive type
(QIIT \cite{DBLP:journals/pacmpl/KaposiKA19}). QIITs are a general
family of inductive types where multiple types are defined mutually,
later types can be indexed over previous ones, and equality
constructors are also allowed, generalising quotients. The elimination
principle of the QIIT corresponds to a structural induction principle
and is equivalent to the statement that the syntax is the initial
model \cite{DBLP:journals/pacmpl/KaposiKA19}, that is, there is a
unique morphism from the syntax to any other model.

conversion to GAT, algebra, models

The traditional way of defining a programming language formally
\cite{DBLP:books/cu/Ha2016,Pierce:SF2,plfa22.08} is comprised of three
steps: (i) definition of the presyntax (abstract syntax trees, ASTs)
as a formal grammar; (ii) specification of
well-formedness/well-typedness relations saying which ASTs are
well-behaved; (iii) specification of rewriting/conversion relations
explaining how programs are executed. Instead of following this route,
we use the intrinsic approach
\cite{DBLP:conf/csl/AltenkirchR99,DBLP:conf/popl/AltenkirchK16}: (i)
we define ASTs as an inductive type instead of production rules of a
grammar; (ii) types are part of the definition and terms are indexed
by them, thus only allowing ASTs to be built in well-typed ways; (iii)
terms are quotiented by conversion rules, making convertible terms
equal. Compared to the traditional extrinsic approach, the intrinsic approach provides
shorter, less technical definitions, and there
is no mismatch between syntax and semantics. Type theory is a
generalised algebraic theory (GAT
\cite{DBLP:journals/apal/Cartmell86}), the notion of model is direct,
and the syntax is simply the initial model. 

There are several ways to define type theory as a GAT. For example,
Thomas Ehrhard's calculus \cite{ehrhard,coquandEhrhard}, Dybjer's
categories with families (CwFs
\cite{DBLP:conf/types/Dybjer95,Castellan2021}), contextual categories
or C-systems
\cite{DBLP:journals/apal/Cartmell86,DBLP:journals/lmcs/AhrensLV18},
natural models \cite{DBLP:journals/mscs/Awodey18}, B-systems
\cite{AHRENS_EMMENEGGER_NORTH_RIJKE_2023}.  With the exception of
B-systems, the listed notions all define a parallel substitution
calculus, where contexts and substitutions form a category. Like
B-systems, in this paper we define a single substitution calculus
(SSC). Single substitutions don't compose, so they do not form a
category. Our definition is simpler than B-systems, but it is closely
related to it. It is a minimalistic presentation where every operation
and equation is well-motivated (see Section \ref{sec:ssc}). In
addition to its pedagogical value due to its simplicity, in the future
it might give rise to new models or contribute to a possible coherent
syntax for type theory, see Section \ref{sec:conclusion}.

CwFs, C-systems, B-systems and our SSC only provide the basic
substitution calculus part of the theory, and individual type formers
(such as function space or product types) have to be specified
separately. There is a systematic way to do this: non-substructural
programming languages can be specified as second-order generalised
algebraic theories (SOGATs \cite{DBLP:conf/fscd/KaposiX24}), which are
GATs allowing second-order operations. For example, type theory with
$\Pi$ and a family of 

Kaposi and Xie \cite{DBLP:conf/fscd/KaposiX24} showed that any SOGAT
has two kinds of GAT semantics, one based on a parallel substitution
calculus, and another based on a single substitution calculus. The
parallel substitution GAT semantics of the SOGAT containing only the
sorts of types and terms ($\Ty : \Set, \Tm : \Ty\ra\Set$) is simply
the GAT of CwFs. The single substitution semantics of the same SOGAT
is the SSC in this paper. 

SOGAT stuff

Our SSC is in some sense too minimalistic: for example, consider a
term $b$ which depends on a context $\Gamma$ and an extra variable of
type $A$, that is, $b : \Tm\,(\Gamma\ext A)\,B$. We weaken $b$ so
that we add an extra $A$ variable \emph{before} the last one obtaining
$
b[\p^+] : \Tm\,(\Gamma\ext A\ext A[\p])\,(B[\p])
$
where $\p$ is
weakening at the end of the context, and $\p^+$ is weakening just
before the last variable in the context. Then, we instantiate the last
$A[\p]$ variable in the context by the previous $A$ obtaining
$b[\p^+][\langle\q\rangle] : \Tm\,(\Gamma\ext A)\,B$ where $\q$ denotes the last
variable in the context (a.k.a\ De Bruijn index $0$).
We cannot derive $b[\p^+][\langle\q\rangle] = b$ in
an arbitrary model, but this equation holds in the syntax.
% p⁺  : Sub (Γ▹A▹A[p]) (Γ▹A)
% ⟨q⟩ : Sub (Γ▹A) (Γ▹A▹A[p])
This is analogous to e.g.\ parametricity results
\cite{DBLP:journals/jfp/BernardyJP12}, which do not hold in an
arbitrary model, but they hold in the syntax. In fact, we can show
that the syntax xxx

In fact, all the
operations and equations of the parallel substitution calculus (CwF)
are admissible in the syntax of SSC, moreover the set of syntactic SSC
terms are isomorphic to the set of CwF terms. In contrast with
B-systems which are equivalent to CwFs, our SSCs do not form
CwFs. Every CwF-based model is a model of our SSC, but not the other
way: there are more SSC-models than CwF-models. The situation is
analogous to the relationship of extensional combinatory calculus and
lambda calculus \cite{DBLP:conf/fscd/AltenkirchKSV23}: the syntactic
terms form isomorphic sets, but there are more combinatory models than
lambda calculus models.

We define the parallel substitution calculus operations by induction
on the SSC-syntax. One of our constructors is the instantiation
operation of single substitutions: $\blank[\blank] :
\Ty\,\Gamma\ra\Sub\,\Delta\,\Gamma\ra\Ty\,\Delta$, and similarly for
terms. When doing induction on terms, we always have to provide a
method for these constructors, but this can be difficult as
substitutions don't compose. This is why we derive a new induction
principle which works on $\alpha$-normal forms. Just as $\beta$-normal
forms don't distinguish between $\beta$-equal terms, $\alpha$-normal
forms don't include explicit substitutions, all the variables are
instantiated. $\alpha$-normal forms are not usual normal forms in the
sense that they are still quotiented by the computation/uniqueness
rules like $\beta$/$\eta$ for function space.

In this paper, we define the SSC and extend it with
$\Pi$ types and a hierarchy of Coquand-universes
\cite{coquandUniverse}. The rules for type formers are the same as for
CwFs, the difference is only in the substitution calculus part. More
generally, every second-order generalised algebraic theory (SOGAT) has
a parallel and a single substition-based first order presentation
\cite{DBLP:conf/fscd/KaposiX24}. Here we prove that the syntaxes of
the parallel and the single substitution calculi are isomorphic for
the following SOGAT 

We conjecture that the methods of in this paper can be used to show
that for any SOGAT, the two first-order presentations give isomorphic
syntaxes.

To summarise, our contributions are the following:
\begin{itemize}
\item A new generalised algebraic presentation of type theory in the
  form of a minimalistic single substitution calculus (SSC).
\item The $\alpha$-normalisation technique which is useful for working
  with explicit substitution calculi.
\item The proof of equivalence of the SSC-syntax with the CwF-based
  syntax.
\end{itemize}

\subsection{Structure of the paper}

In Section \ref{sec:ssc}, we introduce the single substitution
calculus only relying on a working knowledge of an implementation of
type theory such as Agda, no prior experience with the metatheory of
type theory is required. We first show how to get rid of explicit
substitutions from the syntax using the technique of
$\alpha$-normalisation (Section \ref{sec:alpha}), and we use this to
prove several admissible equations. Then we show how to derive the
rules of a CwF from our syntax (Section \ref{sec:cwf}). Finally, we
show that our syntax is isomorphic to the CwF-style syntax (Section
\ref{sec:iso}). We conclude in Section \ref{sec:conclusion}.

\subsection{Related work}

In the 1990s single substitution calculi for type theory were popular,
but usually in the extrinsic setting, see e.g.\ the thesis of
Altenkirch \cite{alti:phd93}. B-systems were introduced by Voevodsky
\cite{voevodsky2014bsystems} as an algebraic way of describing type
theories close to the notations using typing judgements. Using our
notations B-systems can be described as follows. B-frame.


Ehrhard

we use Sub, but we could have used telescopes

\cite{AHRENS_EMMENEGGER_NORTH_RIJKE_2023}

contextual sCwF and contextual SSC with fct types

Formalisations of type theory use low-level 

Algebraic formalisations of type theory: Brunerie

Initiality conjecture.

\cite{initiality-agda} \cite{DBLP:conf/popl/AltenkirchK16},
normalisation, shallow embedding canonicity, gluing. Low level
formalisations: Abel, Loic, metacoq. They can be seen as unfolding the
more abstract thing in a (weak) setoid model.

Other SSC: 90s French, Thorsten thesis, B-systems, Luksa paper.

% TODO: say that this is the paper version of the \cite{singleTypes}
% paper

\subsection{Formalisation}

Our metatheory in which this paper is
written is thus type theory, and everything is formalised in Agda.

As Agda does not support them directly, we postulate their
constructors and induction principle and add the computation rules
using rewrite rules \cite{DBLP:conf/types/Cockx19}.

Notation and formalisation techniques.

\section{Single substitution syntax}
\label{sec:ssc}

Contents of the TYPES abstract, but with more details.
\begin{alignat*}{10}
& \Con && : \Set \\
& \Ty && : \Con\ra\N\ra\Set \\
& \Tm && : (\Gamma:\Con)\ra\Ty\,\Gamma\,i\ra\Set \\
& \diamond && : \Con \\
& \blank\ext\blank && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Con \\
& \Sub && : \Con\ra\Con\ra\Set \\
& \blank[\blank] && : \Ty\,\Gamma\ra\Sub\,\Delta\,\Gamma\ra\Ty\,\Delta \\
& \blank[\blank] && : \Tm\,\Gamma\,A\ra(\gamma:\Sub\,\Delta\,\Gamma)\ra\Tm\,\Delta\,(A[\gamma]) \\
& \p && : \Sub\,(\Gamma\ext A)\,\Gamma \\
& \q && : \Tm\,(\Gamma\ext A)\,(A[\p]) \\
& \Pi && : (A:\Ty\,\Gamma)\ra\Ty\,(\Gamma\ext A)\ra\Ty\,\Gamma \\
& \blank^+ && : (\gamma:\Sub\,\Delta\,\Gamma)\ra\Sub\,(\Delta\ext A[\gamma])\,(\Gamma\ext A) \\
& \Pi[] && : (\Pi\,A\,B)[\gamma] = \Pi\,(A[\gamma])\,(B[\gamma^+]) \\
& \lam && : \Tm\,(\Gamma\ext A)\,B\ra\Tm\,\Gamma\,(\Pi\,A\,B) \\
& \lam[] && : (\lam\,t)[\gamma] = \lam\,(t[\gamma^+]) \\
& \langle\blank\rangle && : \Tm\,\Gamma\,A\ra\Sub\,\Gamma\,(\Gamma\ext A) \\
& \blank\cdot\blank && : \Tm\,\Gamma\,(\Pi\,A\,B)\ra(a:\Tm\,\Gamma\,A)\ra\Tm\,\Gamma\,(B[\langle a\rangle]) \\
& \Pi\beta && : \lam\,t\cdot a = t[\langle a\rangle] \\
& [\langle\rangle] && : B[\langle a\rangle][\gamma] = B[\gamma^+][\langle a[\gamma]\rangle] \\
& {\cdot}[] && : (t\cdot a)[\gamma] = (t[\gamma])\cdot(a[\gamma]) \\
& [\p][^+] && : B[\p][\gamma^+] = B[\gamma][\p] \\
& [\p][^+] && : b[\p][\gamma^+] = b[\gamma][\p] \\
& \q[^+] && : \q[\gamma^+] = \q \\
& [\p][\langle\rangle] && : B[\p][\langle a\rangle] = B \\
& [\p][\langle\rangle] && : b[\p ][\langle a\rangle] = b \\
& \q[\langle\rangle] && : \q[\langle a\rangle] = a \\
& [\p^+][\langle\q\rangle] && : B[\p^+][\langle\q\rangle] = B \\
& \Pi\eta && : t = \lam\,(t[\p]\cdot\q) \\
\end{alignat*}

Show examples of using the calculus, and where we need to derive more
stuff.

\section{$\alpha$-normalisation}
\label{sec:alpha}

$\alpha$-normal forms could also be called substitution normal forms.

\section{Isomorphism}
\label{sec:cwf}

In this section we show that a category with families (CwF) equipped
with a hierarchy of Coquand-universes and $\Pi$ types can be derived
from the single substitution syntax defined in \autoref{sec:ssc}.

TODO: show that the SSC operations are derivable from CwF.

\section{Isomorphism}
\label{sec:iso}

\section{Minimisation}

\section{CwF from SSC with $\Sigma$, $\Pi$ and $\U$}

\section{Conclusions}
\label{sec:conclusion}

Why are we still looking at alternative ways of defining type theory?
Closer to the syntax/implementation, easier to understand/implement,
fewer equations, hence easier to define models, coherent syntax?


In this paper we introduced a new single substitution calculus which
can be seen as a minimalistic variant of B-systems. We illustrate its
usage through the definition of a type theory with dependent function
space and a hierarchy of universes. We aim for accessibility: this
paper can be seen as a tutorial introduction to the syntax of type
theory inside type theory. All the operations and equations are
well-motivated and provide a minimalistic description of the syntax of
type theory. It is minimalistic in the sense that the syntax is
isomorphic to the CwF-syntax, but there are more models. 

The relationship of our single substitution calculus and the CwF-based
theory is similar to that of combinatory logic and lambda calculus
\cite{DBLP:conf/fscd/AltenkirchKSV23}. Combinatory logic has more
models than lambda calculus, but the syntaxes are
isomorphic. Similarly, the single substitution calculus has more
models, but the syntaxes are isomorphic.

A more abstract, higher level description of a language is simply
stating that a language is an algebraic theory: the terms of the
language are given by a sort of the theory, the different term formers
are operations, and the conversion relation is specified by the
equations. Such a description contains less information than the
traditional one, for example, conversion is not oriented, so it is not
clear how to turn it into a rewriting relation; we cannot choose how
much annotations we add to terms, they are always fully
annotated. this is similar to how asts contain less information than
strings, for example, the bracket-removal strategy is not encoded in
asts. the algebraic description automatically induces a notion of
model and the existence of an initial model
\cite{DBLP:journals/pacmpl/KaposiKA19} which we call the syntax. The
algebraic approach is especially natural for languages with dependent
types where typing and conversion have to be specified mutually
\cite{DBLP:conf/popl/AltenkirchK16}.

QIIT is nice because syntax and semantics are given together. The
notion of model/semantics is traditionally given separately, and work
has to be done to show that the above specified syntax generates a
model. For example, this was the goal of the initiality project for
homotopy type theory \cite{brunerie}. Maybe list work on type theory
using QIITs, see TYPES mailing list.

We can abstract over these strategies and define our language as a
second-order generalised algebraic theory
\cite{DBLP:journals/corr/abs-1904-04097}, but to state initiality of
our syntax, at some point we need to turn it into a first-order
algebraic theory \cite{DBLP:conf/fscd/BocquetKS23}.

We conjecture that any SOGAT can be turned into an SSC.

Separate sort for variables, without the extra type equations, by
using assumptions, and proving everything by induction.

\bibliography{b}{}
\bibliographystyle{plain}

\end{document}
