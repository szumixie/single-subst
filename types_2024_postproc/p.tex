\documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\newcommand{\ra}{\rightarrow}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Ty}{\mathsf{Ty}}
\newcommand{\Tm}{\mathsf{Tm}}
\newcommand{\Con}{\mathsf{Con}}
\newcommand{\Sub}{\mathsf{Sub}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\ext}{\mathop{\triangleright}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\lam}{\mathsf{lam}}
\newcommand{\app}{\mathsf{app}}
\newcommand{\U}{\mathsf{U}}
\newcommand{\El}{\mathsf{El}}
\newcommand{\cd}{\mathsf{c}}
\newcommand{\blank}{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}} %from the book

\begin{document}

\title{Type theory in type theory with single substitutions}
\author{Ambrus Kaposi and Szumi Xie}
\date{\today}

\begin{abstract}
Type theory can be described as a generalised algebraic theory. This
automatically gives a notion of model and the existence of the syntax
as the initial model, which is a quotient inductive-inductive
type. Algebraic definitions of type theory include Ehrhard's
definition of model, categories with families (CwFs), contextual
categories, Awodey's natural models, C-systems, B-systems. With the
exception of B-systems, these notions are based on a parallel
substitution calculus where substitutions form a category. In this
paper we define a single substitution calculus (SSC) for type theory
and show that the SSC syntax and the CwF syntax are isomorphic for a
theory with dependent function space and a hierarchy of universes. SSC
only includes single substitutions and single weakenings, and eight
equations relating these: four equations describe how to substitute
variables, and there are four equations on types which are needed to
typecheck other equations. All the other equations are substitution
(naturality) rules or computation rules for different type
formers. SSC provides a simple, minimalistic alternative to parallel
substitution calculi or B-systems for defining type theory. SSC
relates to CwF as extensional combinatory calculus relates to lambda
calculus. All the results in this paper were formalised in Agda.
\end{abstract}

\maketitle

\section{Introduction}

What is type theory? Here we refer to type theory as a particular
formal system based on Martin-Löf's original definition
\cite{martinlof73predicative}, and not to the field studying type
systems (e.g.\ \cite{DBLP:books/daglib/0005958}). When answering this
question, we aim for simplicity and ease of understanding.

The traditional way of defining a programming language formally
\cite{DBLP:books/cu/Ha2016,Pierce:SF2,plfa22.08} is comprised of three
steps: (i) definition of the presyntax (abstract syntax trees, ASTs)
as a formal grammar; (ii) specification of
well-formedness/well-typedness relations saying which ASTs are
well-behaved; (iii) specification of rewriting/conversion relations
explaining how programs are executed. Instead of following this route,
we use the intrinsic approach
\cite{DBLP:conf/csl/AltenkirchR99,DBLP:conf/popl/AltenkirchK16}: (i)
we define ASTs as an inductive type instead of production rules of a
grammar; (ii) terms are indexed by (object theoretic) types, thus only
allowing ASTs to be built in well-typed ways; (iii) terms are
quotiented by conversion rules, making convertible terms equal. The
advantage of the intrinsic approach is that it provides shorter,
easier to understand, less technical definitions, and there is no
mismatch between syntax and semantics. Type theory is a generalised
algebraic theory (GAT \cite{DBLP:journals/apal/Cartmell86}), the
notion of model is direct, and the syntax is simply the initial
model. GATs are generalisations of single-sorted algebraic theories
(such as monoids, groups) to multiple sorts where later sorts can be
indexed over previous sorts. An example is categories with a sort of
objects and a sort of morphisms double-indexed over objects. In a
type-theoretic metatheory, the initial model of a GAT is a quotient
inductive-inductive type (QIIT
\cite{DBLP:journals/pacmpl/KaposiKA19}). QIITs are a general family of
inductive types where multiple types are defined mutually, later types
can be indexed over previous ones, and equality constructors are also
allowed, generalising quotients. The elimination principle of the QIIT
corresponds to a structural induction principle and is
equivalent to the statement that the syntax is the initial model
\cite{DBLP:journals/pacmpl/KaposiKA19}, that is, there is a unique
morphism from the syntax to any other model.

There are several ways to define type theory as a GAT. For example,
Thomas Ehrhard's calculus \cite{ehrhard,coquandEhrhard}, Dybjer's
categories with families (CwFs
\cite{DBLP:conf/types/Dybjer95,Castellan2021}), contextual categories
or C-systems
\cite{DBLP:journals/apal/Cartmell86,DBLP:journals/lmcs/AhrensLV18},
natural models \cite{DBLP:journals/mscs/Awodey18}, B-systems
\cite{AHRENS_EMMENEGGER_NORTH_RIJKE_2023}. These are providing the
basic substitution calculus part of the theory, and individual type
formers (such as function space or product types) have to be specified
separately. With the exception of B-systems, the listed definitions
all define a parallel substitution calculus, where contexts and
substitutions form a category. Like B-systems, in this paper we define
type theory as a single substitution calculus (SSC). Single
substitutions don't compose, so they do not form a category. Our
definition is simpler than B-systems, but it is closely related to
it. It is a minimalistic presentation where every operation and
equation is well-motivated (see Section \ref{sec:ssc}). In addition to
its pedagogical value due to its simplicity, our definition might
contribute in the future to a possible coherent syntax for type
theory, see Section \ref{sec:conclusion}.

Our theory is in some sense too minimalistic: for example, consider a
term $b$ which depends on a context $\Gamma$ and an extra variable of
type $A$, that is, $b : \Tm\,(\Gamma\ext A)\,B$. We can weaken $b$ so
that we add an extra $A$ variable \emph{before} the last one obtaining
$b[\p^+] : \Tm\,(\Gamma\ext A\ext A[\p])\,(B[\p])$ where $\p$ is
weakening at the end of the context, and $\p^+$ is weakening just
before the last variable in the context. Then, we instantiate the last
$A[\p]$ variable in the context by the previous $A$ obtaining
$b[\p^+][\langle\q\rangle] : \Tm\,(\Gamma\ext A)\,B$ where $\q$ is De
Bruijn index $0$. We cannot derive $b[\p^+][\langle\q\rangle] = b$ in
an arbitrary model, but this equation holds in the syntax.
% p⁺  : Sub (Γ▹A▹A[p]) (Γ▹A)
% ⟨q⟩ : Sub (Γ▹A) (Γ▹A▹A[p])
This is analogous to e.g.\ parametricity results
\cite{DBLP:journals/jfp/BernardyJP12}, which do not hold in an
arbitrary model, but they hold for syntactic terms. In fact, all the
operations and equations of the parallel substitution calculus (CwF)
are admissible in our syntax, moreover the set of SSC-based syntactic
terms are isomorphic to the set of CwF-based terms. In contrast with
B-systems which are equivalent to CwFs, our SSC-models do not form
CwF-based models. Every CwF-based model is a model of our SSC, but not
the other way: there are more SSC-models than CwF-models. The
situation is analogous to the relationship of extensional combinatory
calculus and lambda calculus \cite{DBLP:conf/fscd/AltenkirchKSV23}:
the syntactic terms form isomorphic sets, but there are more
combinatory models than lambda calculus models.

We define the parallel substitution calculus operations by induction
on the SSC-syntax. One of our constructors is the instantiation
operation of single substitutions: $\blank[\blank] :
\Ty\,\Gamma\ra\Sub\,\Delta\,\Gamma\ra\Ty\,\Delta$, and similarly for
terms. When doing induction on terms, we always have to provide a
method for these constructors, but this can be difficult as
substitutions don't compose. This is why we derive a new induction
principle which works on $\alpha$-normal forms. Just as $\beta$-normal
forms don't distinguish between $\beta$-equal terms, $\alpha$-normal
forms don't include explicit substitutions, all the variables are
instantiated. $\alpha$-normal forms are not usual normal forms in the
sense that they are still quotiented by the computation/uniqueness
rules like $\beta$/$\eta$ for function space.

In this paper, we define the SSC and extend it with
$\Pi$ types and a hierarchy of Coquand-universes
\cite{coquandUniverse}. The rules for type formers are the same as for
CwFs, the difference is only in the substitution calculus part. More
generally, every second-order generalised algebraic theory (SOGAT) has
a parallel and a single substition-based first order presentation
\cite{DBLP:conf/fscd/KaposiX24}. Here we prove that the syntaxes of
the parallel and the single substitution calculi are isomorphic for
the following SOGAT (we use implicit arguments and $\cong$ denotes
isomorphism):
\begin{alignat*}{10}
  & \Ty && : \N\ra\Set \\
  & \Tm && : \Ty\,i\ra\Set \\
  & \Pi && : (A:\Ty\,i)\ra(\Tm\,A\ra\Ty\,i)\ra\Ty\,i \\
  & \app && : \Tm\,(\Pi\,A\,B)\cong((a:\Tm\,A)\ra\,\Tm\,(B\,a)): \lam \\
  & \U && : (i:\N)\ra\Ty\,(1+i) \\
  & \El && : \Tm\,(\U\,i)\cong\Ty\,i : \cd
\end{alignat*}
We conjecture that the methods of in this paper can be used to show
that for any SOGAT, the two first-order presentations give isomorphic
syntaxes.

To summarise, our contributions are the following:
\begin{itemize}
\item A new generalised algebraic presentation of type theory in the
  form of a minimalistic single substitution calculus (SSC).
\item The $\alpha$-normalisation technique which is useful for working
  with explicit substitution calculi.
\item The proof of equivalence of the SSC-syntax with the CwF-based
  syntax.
\end{itemize}

\subsection{Structure of the paper}

In Section \ref{sec:ssc}, we introduce the single substitution
calculus only relying on a working knowledge of an implementation of
type theory such as Agda, no prior experience with the metatheory of
type theory is required. We first show how to get rid of explicit
substitutions from the syntax using the technique of
$\alpha$-normalisation (Section \ref{sec:alpha}), and we use this to
prove several admissible equations. Then we show how to derive the
rules of a CwF from our syntax (Section \ref{sec:cwf}). Finally, we
show that our syntax is isomorphic to the CwF-style syntax (Section
\ref{sec:iso}). We conclude in Section \ref{sec:conclusion}.

\subsection{Related work}

Most formalisation of type theory use low-level 

Algebraic formalisations of type theory: Brunerie

\cite{initiality-agda} \cite{DBLP:conf/popl/AltenkirchK16},
normalisation, shallow embedding canonicity, gluing. Low level
formalisations: Abel, Loic, metacoq. They can be seen as unfolding the
more abstract thing in a (weak) setoid model.

Other SSC: 90s French, Thorsten thesis, B-systems, Luksa paper.

% TODO: say that this is the paper version of the \cite{singleTypes}
% paper

\subsection{Formalisation}

Our metatheory in which this paper is
written is thus type theory, and everything is formalised in Agda.

As Agda does not support them directly, we postulate their
constructors and induction principle and add the computation rules
using rewrite rules \cite{DBLP:conf/types/Cockx19}.

Notation and formalisation techniques.

\section{Single substitution syntax}
\label{sec:ssc}

Contents of the TYPES abstract, but with more details.

Show examples of using the calculus, and where we need to derive more
stuff.

\section{$\alpha$-normalisation}
\label{sec:alpha}

$\alpha$-normal forms could also be called substitution normal forms.

\section{Isomorphism}
\label{sec:cwf}

In this section we show that a category with families (CwF) equipped
with a hierarchy of Coquand-universes and $\Pi$ types can be derived
from the single substitution syntax defined in \autoref{sec:ssc}.

TODO: show that the SSC operations are derivable from CwF.

\section{Isomorphism}
\label{sec:iso}

\section{Conclusions}
\label{sec:conclusion}

In this paper we introduced a new single substitution calculus which
can be seen as a minimalistic variant of B-systems. We illustrate its
usage through the definition of a type theory with dependent function
space and a hierarchy of universes. We aim for accessibility: this
paper can be seen as a tutorial introduction to the syntax of type
theory inside type theory. All the operations and equations are
well-motivated and provide a minimalistic description of the syntax of
type theory. It is minimalistic in the sense that the syntax is
isomorphic to the CwF-syntax, but there are more models. 

The relationship of our single substitution calculus and the CwF-based
theory is similar to that of combinatory logic and lambda calculus
\cite{DBLP:conf/fscd/AltenkirchKSV23}. Combinatory logic has more
models than lambda calculus, but the syntaxes are
isomorphic. Similarly, the single substitution calculus has more
models, but the syntaxes are isomorphic.

A more abstract, higher level description of a language is simply
stating that a language is an algebraic theory: the terms of the
language are given by a sort of the theory, the different term formers
are operations, and the conversion relation is specified by the
equations. Such a description contains less information than the
traditional one, for example, conversion is not oriented, so it is not
clear how to turn it into a rewriting relation; we cannot choose how
much annotations we add to terms, they are always fully
annotated. this is similar to how asts contain less information than
strings, for example, the bracket-removal strategy is not encoded in
asts. the algebraic description automatically induces a notion of
model and the existence of an initial model
\cite{DBLP:journals/pacmpl/KaposiKA19} which we call the syntax. The
algebraic approach is especially natural for languages with dependent
types where typing and conversion have to be specified mutually
\cite{DBLP:conf/popl/AltenkirchK16}.

QIIT is nice because syntax and semantics are given together. The
notion of model/semantics is traditionally given separately, and work
has to be done to show that the above specified syntax generates a
model. For example, this was the goal of the initiality project for
homotopy type theory \cite{brunerie}. Maybe list work on type theory
using QIITs, see TYPES mailing list.

We can abstract over these strategies and define our language as a
second-order generalised algebraic theory
\cite{DBLP:journals/corr/abs-1904-04097}, but to state initiality of
our syntax, at some point we need to turn it into a first-order
algebraic theory \cite{DBLP:conf/fscd/BocquetKS23}.

We conjecture that any SOGAT can be turned into an SSC.

Separate sort for variables, without the extra type equations, by
using assumptions, and proving everything by induction.

\bibliography{b}{}
\bibliographystyle{plain}

\end{document}
