\documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\newcommand{\ra}{\rightarrow}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Ty}{\mathsf{Ty}}
\newcommand{\Tm}{\mathsf{Tm}}
\newcommand{\Con}{\mathsf{Con}}
\newcommand{\Sub}{\mathsf{Sub}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\ext}{\mathop{\triangleright}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\lam}{\mathsf{lam}}
\newcommand{\app}{\mathsf{app}}
\newcommand{\U}{\mathsf{U}}
\newcommand{\El}{\mathsf{El}}
\newcommand{\cd}{\mathsf{c}}
\newcommand{\blank}{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}} %from the book

\begin{document}

\title{Type theory in type theory with single substitutions}
\author{Ambrus Kaposi and Szumi Xie}
\date{\today}

\begin{abstract}
Type theory can be described as a generalised algebraic theory. This
automatically gives a notion of model and the existence of the syntax
as the initial model, which is a quotient inductive-inductive
type. Algebraic definitions of type theory include Ehrhard's
definition of model, categories with families (CwFs), contextual
categories, Awodey's natural models, C-systems, B-systems. With the
exception of B-systems, these notions are based on a parallel
substitution calculus where substitutions form a category. In this
paper we define a single substitution calculus (SSC) for type theory
and show that the SSC syntax and the CwF syntax are isomorphic for a
theory with dependent function space and a hierarchy of universes. SSC
only includes single substitutions and single weakenings, and eight
equations relating these: four equations describe how to substitute
variables, and there are four equations on types which are needed to
typecheck other equations. All the other equations are substitution
(naturality) rules or computation rules for different type
formers. SSC provides a simple, minimalistic alternative to parallel
substitution calculi or B-systems for defining type theory. SSC
relates to CwF as extensional combinatory calculus relates to lambda
calculus. All the results in this paper were formalised in Agda.
\end{abstract}

\maketitle

\section{Introduction}

What is type theory? Here we refer to type theory as a particular
formal system based on Martin-Löf's original definition
\cite{martinlof73predicative}, and not to the field studying type
systems (e.g.\ \cite{DBLP:books/daglib/0005958}).

Type theory is a language which can be described as a second-order
generalised algebraic theory (SOGAT
\cite{DBLP:conf/fscd/KaposiX24}). Some properties of this description:
\begin{enumerate}
\item[(i)] It is an intrinsic presentation
  \cite{DBLP:conf/csl/AltenkirchR99,DBLP:conf/popl/AltenkirchK16} as
  opposed to extrinsic \cite{abel2013normalization,theo}. That is, we
  only consider well-formed, well-scoped and well-typed abstract
  syntax trees, there are no meaningless terms.
\item[(ii)] Terms are quotiented by the conversion relation.
\item[(iii)] Every operation is stable under substitution.
\end{enumerate}
For example, type theory with $\Pi$ types and universes {\`a} la
Coquand \cite{coquandUniverse} is specified by the following SOGAT.
\begin{equation}\label{eq:tt}
\begin{alignedat}{10}
  & \Ty && : \N\ra\Set \\
  & \Tm && : \Ty\,i\ra\Set \\
  & \Pi && : (A:\Ty\,i)\ra(\Tm\,A\ra\Ty\,i)\ra\Ty\,i \\
  & \app && : \Tm\,(\Pi\,A\,B)\cong((a:\Tm\,A)\ra\,\Tm\,(B\,a)): \lam \\
  & \U && : (i:\N)\ra\Ty\,(1+i) \\
  & \El && : \Tm\,(\U\,i)\cong\Ty\,i : \cd
\end{alignedat}
\end{equation}
We use implicit arguments, e.g.\ $\Tm$ takes the $i:\N$ implicitly,
and $\app$ takes $i$, $A$ and $B$ implicitly. $f : X \cong Y : g$
denotes an isomorphism, that is, $f : X\ra Y$, $g:Y\ra X$ with
$g\,(f\,x) = x$ and $f\,(g\,y) = y$ for all $x$, $y$. Note that $\Pi$
and $\lam$ are second-order functions. We say that $\Pi$ binds a
$\Tm$-variable of type $A$ in its second $\Ty$-argument. Every binder
is represented by a second-order function, and as a result, we don't
need to talk about contexts and substitutions when describing the
theory: we re-use the binding features of the metatheory to describe
those of our object theory (this technique is also known as
higher-order abstract syntax \cite{DBLP:conf/lics/Hofmann99} or
logical framework
\cite{DBLP:journals/jacm/HarperHP93,10.1007/978-3-642-14203-1_2}). There
is no good notion of homomorphism between second-order models, thus
the semantics of a SOGAT is given by a first order generalised
algebraic theory (GAT \cite{DBLP:journals/apal/Cartmell86}). GATs are
generalisations of single-sorted algebraic theories (such as monoids,
groups) to multiple sorts where later sorts can be indexed over
previous sorts. The usual results from universal algebra (e.g.\ models
form a category with finite limits and initial object, existence of
free and co-free models) carry over to GATs
\cite{andras,DBLP:phd/hal/Moeneclaey22}. An example of a GAT is the
theory of categories where there is a sort for objects and a sort for
morphisms double-indexed over objects.

Kaposi and Xie \cite{DBLP:conf/fscd/KaposiX24} present two different
first order semantics for any SOGAT: one based on parallel
substitutions, and one based on single substitutions.

In the parallel semantics, the GAT always starts with a category with
a terminal object, objects of the category are called contexts,
morphisms are substitutions. Every sort/operation of the SOGAT gives
rise to a sort/operation in the GAT which is now indexed by
contexts. The sorts moreoever come with instantiation (sometimes
called substitution) operations which are functorial, and all the
operations are natural with respect to instantiation. For those sorts
which are bound by an operation in the SOGAT description, we have
context extension, meaning that contexts can carry variables of that
sort (in other words, the sort is given by a locally representable
presheaf). The parallel semantics of the SOGAT
\begin{equation}\label{eq:tytm}
\begin{alignedat}{10}
  & \Ty && : \Set \\
  & \Tm && : \Ty \ra\Set 
\end{alignedat}
\end{equation}
is the GAT of categories with families (CwFs
\cite{DBLP:conf/types/Dybjer95,Castellan2021}). We define the notion
of model of a language (a SOGAT) by its parallel substitution
semantics, which is a GAT, and that induces a notion of model. The
syntax of the language is the initial model, which exists for every
GAT \cite{DBLP:journals/pacmpl/KaposiKA19}. This is an intrinsic
syntax (only well-typed terms), quotiented by the equations in the
SOGAT, which describe conversion for the language.

The single substitution semantics is a GAT which does not start with a
category: there are contexts and maps between contexts, but these maps
are single substitutions or single weakenings, they don't
compose. There are fewer operations and fewer equations than in the
parallel semantics. In this paper we investigate the single
substitution semantics of the type theory specified by the SOGAT
(\ref{eq:tt}). This presentation of type theory is simpler than CwFs,
the operations are all easy to motivate, we illustrate this in Section
\ref{sec:ssc}. Single substitution calculi are closer to the usual
presentation of type theory using derivation rules, this was one of
the motivations of Voevodsky for developing B-systems
\cite{AHRENS_EMMENEGGER_NORTH_RIJKE_2023}. Our single substitution
semantics of (\ref{eq:tytm}) is simpler and has more models than
B-systems. GAT presentations of type theory are important for defining
models, our presentation gives a new notion of model, which in the
future might contribute to definitions of new models. Because our
single substitution GAT does not involve a category, it might be
easier to adapt it in a higher dimensional setting, see Section
\ref{sec:conclusion}.

The single substitution semantics of (\ref{eq:tytm}) is in some sense
too minimalistic: for example, consider a term $b$ which depends on a
context $\Gamma$ and an extra variable of type $A$, that is, $b :
\Tm\,(\Gamma\ext A)\,B$. We weaken $b$ so that we add an extra $A$
variable \emph{before} the last one obtaining $ b[\p^+] :
\Tm\,(\Gamma\ext A\ext A[\p])\,(B[\p]) $ where $\p$ is weakening at
the end of the context, and $\p^+$ is weakening just before the last
variable in the context. Then, we instantiate the last $A[\p]$
variable in the context by the previous $A$ obtaining
$b[\p^+][\langle\q\rangle] : \Tm\,(\Gamma\ext A)\,B$ where $\q$
denotes the last variable in the context (a.k.a\ De Bruijn index $0$).
We cannot derive $b[\p^+][\langle\q\rangle] = b$ in an arbitrary
model, but this equation holds in the syntax.
% p⁺  : Sub (Γ▹A▹A[p]) (Γ▹A)
% ⟨q⟩ : Sub (Γ▹A) (Γ▹A▹A[p])
This is analogous to e.g.\ parametricity results
\cite{DBLP:journals/jfp/BernardyJP12}, which do not hold in an
arbitrary model, but they hold in the syntax. In fact, we show that
the single substitution syntax of (\ref{eq:tt}) is equivalent to the
parallel substitution syntax of (\ref{eq:tt}), and the techniques that
we use here are not specific to the SOGAT (\ref{eq:tt}), we expect
that they work for any SOGAT. Equivalence of the syntaxes means that
the corresponding sorts ($\Con$, $\Ty$, $\Tm$) are isomorphic. For a
general SOGAT, there are more models of the correponding single
substitution GAT than the parallel substitution GAT. Every parallel
model is also a single model, but not necessarily the other way. While
B-systems are equivalent to CwFs (and C-systems
\cite{AHRENS_EMMENEGGER_NORTH_RIJKE_2023}), there are more single
substitution models of (\ref{eq:tt}) than parallel substitution
models. The situation is similar to that of extensional combinatory
calculus and lambda calculus, where the syntaxes are equivalent, and
every lambda model is a combinatory model, but not the other way round
\cite{DBLP:conf/fscd/AltenkirchKSV23}. A simpler example is the
relationship of monoids over a set $X$ and nil/cons algebras over $X$,
where every monoid is a nil/cons-algebra, but not the other way; it is
well-known that free monoids over $X$ (syntax for monoid over $X$) are
the same as lists of $X$ (the syntax for nil/cons algebras over $X$).

When showing that the parallel and single substitution syntaxes are
equivalent, we define the parallel operations by induction on the
single substitution syntax. One of the operations in the single
substitution syntax is the instantiation operation: $\blank[\blank] :
\Ty\,\Gamma\ra\Sub\,\Delta\,\Gamma\ra\Ty\,\Delta$, and similarly for
terms. When doing induction on types/terms, we always have to provide
a method for these operations, but this can be difficult as
substitutions don't compose. This is why we derive a new induction
principle which works on $\alpha$-normal types and terms. Just as
$\beta$-normal forms don't distinguish between $\beta$-equal terms,
$\alpha$-normal forms don't include explicit substitutions, all the
variables are instantiated. $\alpha$-normal forms are not usual normal
forms in the sense that they are still quotiented by the
computation/uniqueness rules like $\beta$/$\eta$ for function
space. To derive the new induction principle for the syntax, we first
prove $\alpha$-normalisation.

if we have U,Pi, we can minimise the syntax

if we have U,Pi,Sigma, then SSC semantics of (1)+Sigma -> PSC semantics of (1)+Sigma.

To summarise, our contributions are the following:
\begin{itemize}
\item A new generalised algebraic presentation of type theory in the
  form of a minimalistic single substitution calculus.
\item The $\alpha$-normalisation technique and deriving parallel
  substitutions from the single substitution syntax.
\item Minimisation.
\item For type theory with $\Pi$, $\U$, $\top$ and $\Sigma$, deriving
  a parallel model from a single substitution model.
\end{itemize}

\subsection{Structure of the paper}

In Section \ref{sec:ssc}, we introduce the single substitution
calculus only relying on a working knowledge of an implementation of
type theory such as Agda, no prior experience with the metatheory of
type theory is required. We first show how to get rid of explicit
substitutions from the syntax using the technique of
$\alpha$-normalisation (Section \ref{sec:alpha}), and we use this to
prove several admissible equations. Then we show how to derive the
rules of a CwF from our syntax (Section \ref{sec:cwf}). Finally, we
show that our syntax is isomorphic to the CwF-style syntax (Section
\ref{sec:iso}). We conclude in Section \ref{sec:conclusion}.

\subsection{Related work}

In the 1990s single substitution calculi for type theory were popular,
but usually in the extrinsic setting, see e.g.\ the thesis of
Altenkirch \cite{alti:phd93}. B-systems were introduced by Voevodsky
\cite{voevodsky2014bsystems} as an algebraic way of describing type
theories close to the notations using typing judgements. Using our
notations B-systems can be described as follows. B-frame.

There are several ways to define type theory as a GAT. For example,
Thomas Ehrhard's calculus \cite{ehrhard,coquandEhrhard}, Dybjer's
categories with families (CwFs
\cite{DBLP:conf/types/Dybjer95,Castellan2021}), contextual categories
or C-systems
\cite{DBLP:journals/apal/Cartmell86,DBLP:journals/lmcs/AhrensLV18},
natural models \cite{DBLP:journals/mscs/Awodey18}, B-systems
\cite{AHRENS_EMMENEGGER_NORTH_RIJKE_2023}.  With the exception of
B-systems, the listed notions all define a parallel substitution
calculus, where contexts and substitutions form a category.


Ehrhard

we use Sub, but we could have used telescopes

contextual sCwF and contextual SSC with fct types

Formalisations of type theory use low-level 

Algebraic formalisations of type theory: Brunerie

Initiality conjecture.

\cite{initiality-agda} \cite{DBLP:conf/popl/AltenkirchK16},
normalisation, shallow embedding canonicity, gluing. Low level
formalisations: Abel, Loic, metacoq. They can be seen as unfolding the
more abstract thing in a (weak) setoid model.

Other SSC: 90s French, Thorsten thesis, B-systems, Luksa paper.

% TODO: say that this is the paper version of the \cite{singleTypes}
% paper

In a type-theoretic metatheory,
the initial model of a GAT is a quotient inductive-inductive type
(QIIT \cite{DBLP:journals/pacmpl/KaposiKA19}). QIITs are a general
family of inductive types where multiple types are defined mutually,
later types can be indexed over previous ones, and equality
constructors are also allowed, generalising quotients. The elimination
principle of the QIIT corresponds to a structural induction principle
and is equivalent to the statement that the syntax is the initial
model \cite{DBLP:journals/pacmpl/KaposiKA19}, that is, there is a
unique morphism from the syntax to any other model.


\subsection{Metatheory and formalisation}

Our metatheory in which this paper is
written is thus type theory, and everything is formalised in Agda.

As Agda does not support them directly, we postulate their
constructors and induction principle and add the computation rules
using rewrite rules \cite{DBLP:conf/types/Cockx19}.

Notation and formalisation techniques.

Prop.

\section{Single substitution syntax}
\label{sec:ssc}

Contents of the TYPES abstract, but with more details.
\begin{alignat*}{10}
& \Con && : \Set \\
& \Ty && : \Con\ra\N\ra\Set \\
& \Tm && : (\Gamma:\Con)\ra\Ty\,\Gamma\,i\ra\Set \\
& \diamond && : \Con \\
& \blank\ext\blank && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Con \\
& \Sub && : \Con\ra\Con\ra\Set \\
& \blank[\blank] && : \Ty\,\Gamma\ra\Sub\,\Delta\,\Gamma\ra\Ty\,\Delta \\
& \blank[\blank] && : \Tm\,\Gamma\,A\ra(\gamma:\Sub\,\Delta\,\Gamma)\ra\Tm\,\Delta\,(A[\gamma]) \\
& \p && : \Sub\,(\Gamma\ext A)\,\Gamma \\
& \q && : \Tm\,(\Gamma\ext A)\,(A[\p]) \\
& \Pi && : (A:\Ty\,\Gamma)\ra\Ty\,(\Gamma\ext A)\ra\Ty\,\Gamma \\
& \blank^+ && : (\gamma:\Sub\,\Delta\,\Gamma)\ra\Sub\,(\Delta\ext A[\gamma])\,(\Gamma\ext A) \\
& \Pi[] && : (\Pi\,A\,B)[\gamma] = \Pi\,(A[\gamma])\,(B[\gamma^+]) \\
& \lam && : \Tm\,(\Gamma\ext A)\,B\ra\Tm\,\Gamma\,(\Pi\,A\,B) \\
& \lam[] && : (\lam\,t)[\gamma] = \lam\,(t[\gamma^+]) \\
& \langle\blank\rangle && : \Tm\,\Gamma\,A\ra\Sub\,\Gamma\,(\Gamma\ext A) \\
& \blank\cdot\blank && : \Tm\,\Gamma\,(\Pi\,A\,B)\ra(a:\Tm\,\Gamma\,A)\ra\Tm\,\Gamma\,(B[\langle a\rangle]) \\
& \Pi\beta && : \lam\,t\cdot a = t[\langle a\rangle] \\
& [\langle\rangle] && : B[\langle a\rangle][\gamma] = B[\gamma^+][\langle a[\gamma]\rangle] \\
& {\cdot}[] && : (t\cdot a)[\gamma] = (t[\gamma])\cdot(a[\gamma]) \\
& [\p][^+] && : B[\p][\gamma^+] = B[\gamma][\p] \\
& [\p][^+] && : b[\p][\gamma^+] = b[\gamma][\p] \\
& \q[^+] && : \q[\gamma^+] = \q \\
& [\p][\langle\rangle] && : B[\p][\langle a\rangle] = B \\
& [\p][\langle\rangle] && : b[\p ][\langle a\rangle] = b \\
& \q[\langle\rangle] && : \q[\langle a\rangle] = a \\
& [\p^+][\langle\q\rangle] && : B[\p^+][\langle\q\rangle] = B \\
& \Pi\eta && : t = \lam\,(t[\p]\cdot\q) \\
\end{alignat*}

Show examples of using the calculus, and where we need to derive more
stuff.

\section{$\alpha$-normalisation}
\label{sec:alpha}

$\alpha$-normal forms could also be called substitution normal forms.

\section{Isomorphism}
\label{sec:cwf}

In this section we show that a category with families (CwF) equipped
with a hierarchy of Coquand-universes and $\Pi$ types can be derived
from the single substitution syntax defined in \autoref{sec:ssc}.

TODO: show that the SSC operations are derivable from CwF.

\section{Minimisation}

\section{CwF from SSC with $\Sigma$, $\Pi$ and $\U$}

\section{Conclusions}
\label{sec:conclusion}

Why are we still looking at alternative ways of defining type theory?
Closer to the syntax/implementation, easier to understand/implement,
fewer equations, hence easier to define models, coherent syntax?


In this paper we introduced a new single substitution calculus which
can be seen as a minimalistic variant of B-systems. We illustrate its
usage through the definition of a type theory with dependent function
space and a hierarchy of universes. We aim for accessibility: this
paper can be seen as a tutorial introduction to the syntax of type
theory inside type theory. All the operations and equations are
well-motivated and provide a minimalistic description of the syntax of
type theory. It is minimalistic in the sense that the syntax is
isomorphic to the CwF-syntax, but there are more models. 

The relationship of our single substitution calculus and the CwF-based
theory is similar to that of combinatory logic and lambda calculus
\cite{DBLP:conf/fscd/AltenkirchKSV23}. Combinatory logic has more
models than lambda calculus, but the syntaxes are
isomorphic. Similarly, the single substitution calculus has more
models, but the syntaxes are isomorphic.

A more abstract, higher level description of a language is simply
stating that a language is an algebraic theory: the terms of the
language are given by a sort of the theory, the different term formers
are operations, and the conversion relation is specified by the
equations. Such a description contains less information than the
traditional one, for example, conversion is not oriented, so it is not
clear how to turn it into a rewriting relation; we cannot choose how
much annotations we add to terms, they are always fully
annotated. this is similar to how asts contain less information than
strings, for example, the bracket-removal strategy is not encoded in
asts. the algebraic description automatically induces a notion of
model and the existence of an initial model
\cite{DBLP:journals/pacmpl/KaposiKA19} which we call the syntax. The
algebraic approach is especially natural for languages with dependent
types where typing and conversion have to be specified mutually
\cite{DBLP:conf/popl/AltenkirchK16}.

QIIT is nice because syntax and semantics are given together. The
notion of model/semantics is traditionally given separately, and work
has to be done to show that the above specified syntax generates a
model. For example, this was the goal of the initiality project for
homotopy type theory \cite{brunerie}. Maybe list work on type theory
using QIITs, see TYPES mailing list.

We can abstract over these strategies and define our language as a
second-order generalised algebraic theory
\cite{DBLP:journals/corr/abs-1904-04097}, but to state initiality of
our syntax, at some point we need to turn it into a first-order
algebraic theory \cite{DBLP:conf/fscd/BocquetKS23}.

We conjecture that any SOGAT can be turned into an SSC.

Separate sort for variables, without the extra type equations, by
using assumptions, and proving everything by induction.

\bibliography{b}{}
\bibliographystyle{plain}

\end{document}
