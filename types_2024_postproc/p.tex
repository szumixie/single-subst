\documentclass[a4paper]{article}

\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}

\begin{document}

\title{Type theory in type theory with single substitutions}
\author{Ambrus Kaposi and Szumi Xie}
\date{\today}
\maketitle

\begin{abstract}
Type theory can be described as a generalised algebraic theory which
automatically gives a notion of model and the existence of the syntax
as the initial model, which is a quotient inductive-inductive
type. Such descriptions include Ehrhard's definition of model,
categories with families (CwF), contextual categories, Awodey's
natural models, C-systems and B-systems. With the exception of
B-systems, these notions are based on a parallel substitution calculus
where substitutions form a category. In this paper we define a single
substitution calculus (SSC) for type theory and show that the SSC
syntax and the CwF syntax are isomorphic for a theory with dependent
function space and universe. SSC only includes single substitutions
and single weakenings, and six equations relating these. Four
equations describe how to substitute variables, and two more equations
are needed to typecheck these four equations. SSC provides a simple,
minimalistic alternative to parallel substitution calculi or B-systems
for defining type theory. All the results in this paper were
formalised in Agda.
\end{abstract}

\section{Introduction}

\cite{singleTypes}
\cite{coquandEhrhard}

What is type theory? This term can refer to formal systems (languages,
type systems, type theories) or to the field of study of type
theories. In this paper, we will give an answer to this question in
the form of a concrete formal system. We aim for simplicity and ease
of understanding: we only require a working knowledge of Agda, a
functional programming language which is an implementation of type
theory. Our metatheory in which this paper is written is thus type
theory, and everything is formalised in Agda.

The traditional way of defining a programming language formally
\cite{DBLP:books/daglib/0005958,DBLP:books/cu/Ha2016,Pierce:SF1,plfa22.08}
is comprised of three steps: (i) definition of the presyntax
(abstract syntax trees, ASTs) as a formal grammar; (ii) specification of
well-formedness/well-typedness relations saying which ASTs are
well-behaved; (iii) specification of rewriting/conversion relations
explaining how programs are executed. Instead of following this route,
we use the intrinsic approach
\cite{DBLP:conf/csl/AltenkirchR99,DBLP:conf/popl/AltenkirchK16}: (i)
we define ASTs as an inductive type instead of production rules of a
grammar; (ii) terms are indexed by (object theoretic) types, thus only
allowing ASTs to be plugged together in well-typed ways; (iii) terms
are quotiented by conversion rules, making convertible terms
equal. Inductive types which allow such mutual indexing and
quotienting are called quotient inductive-inductive types (QIITs
\cite{DBLP:journals/pacmpl/KaposiKA19}). As Agda does not support them
directly, we postulate their constructors and induction principle and add the
computation rules using rewrite rules \cite{DBLP:conf/types/Cockx19}.

A QIIT is also the initial algebra/model of a generalised algebraic
theory (GAT \cite{DBLP:journals/apal/Cartmell86}). The induction principle of
the QIIT is equivalent to having a unique morphism into any model
\cite{DBLP:journals/pacmpl/KaposiKA19}. There are several ways to
define type theory as a GAT: categories with families (CwFs
\cite{DBLP:journals/corr/abs-1904-00827}), contextual categories
\cite{DBLP:journals/apal/Cartmell86}, natural models
\cite{DBLP:journals/mscs/Awodey18}, C-systems and B-systems
\cite{ahrens_emmenegger_north_rijke_2023}. When extracting a QIIT from
a GAT, with the exception of B-systems, we obtain parallel
substitution calculi. Like B-systems, in this paper we define type
theory using \emph{single substitutions}. Our definition is simpler
than B-systems, but it is closely related to it. It is a minimalistic
presentation where every operation and equation is well-motivated (see
Section \ref{sec:SSC}). However, when we want to use our syntax (for
example, if we want to prove canonicity or normalisation for our
theory), it is much more convenient to use parallel substitution
calculi such as CwFs. We first show how to get rid of explicit
substitutions from the syntax using the technique of
$\alpha$-normalisation (Section \ref{sec:alpha}). Then we show how to
derive the rules of a CwF from our syntax (Section
\ref{sec:cwf}). Finally, we show that our syntax is isomorphic to the
CwF-style syntax (Section \ref{sec:iso}). We list related work and
conclude in Section \ref{sec:conclusion}.

Our main contribution is the novel definition of a minimalistic single
substitution calculus, the $\alpha$-normalisation algorithm which can
be useful for other explicit substitution calculi, and finally our
proof of equivalence with the CwF-style syntax.

\subsection{Formalisation}

Notation and formalisation techniques.

\subsection{Structure of the paper}

\section{Single substitution syntax}
\label{sec:ssc}

Contents of the TYPES abstract, but with more details.

\section{The single substitution syntax is a category with families}

In this section we show that a category with families (CwF) equipped
with a hierarchy of Coquand-universes and $\Pi$ types can be derived
from the single substitution syntax defined in \autoref{sec:ssc}.

\section{Related work and conclusion}

In this paper we introduced a new single substitution calculus which
can be seen as a minimalistic variant of B-systems. We illustrate its
usage through the definition of a type theory with dependent function
space and a hierarchy of universes. We aim for accessibility: this
paper can be seen as a tutorial introduction to the syntax of type
theory inside type theory. All the operations and equations are
well-motivated and provide a minimalistic description of the syntax of
type theory. It is minimalistic in the sense that the syntax is
isomorphic to the CwF-syntax, but there are more models. 

The relationship of our single substitution calculus and the CwF-based
theory is similar to that of combinatory logic and lambda calculus
\cite{DBLP:conf/fscd/AltenkirchKSV23}. Combinatory logic has more
models than lambda calculus, but the syntaxes are
isomorphic. Similarly, the single substitution calculus has more
models, but the syntaxes are isomorphic.

SSC was used in the 90s for simple type theories, ask Hugo for references.

A more abstract, higher level description of a language is simply
stating that a language is an algebraic theory: the terms of the
language are given by a sort of the theory, the different term formers
are operations, and the conversion relation is specified by the
equations. Such a description contains less information than the
traditional one, for example, conversion is not oriented, so it is not
clear how to turn it into a rewriting relation; we cannot choose how
much annotations we add to terms, they are always fully
annotated. this is similar to how asts contain less information than
strings, for example, the bracket-removal strategy is not encoded in
asts. the algebraic description automatically induces a notion of
model and the existence of an initial model
\cite{DBLP:journals/pacmpl/KaposiKA19} which we call the syntax. The
algebraic approach is especially natural for languages with dependent
types where typing and conversion have to be specified mutually
\cite{DBLP:conf/popl/AltenkirchK16}.

QIIT is nice because syntax and semantics are given together. The
notion of model/semantics is traditionally given separately, and work
has to be done to show that the above specified syntax generates a
model. For example, this was the goal of the initiality project for
homotopy type theory \cite{brunerie}. Maybe list work on type theory
using QIITs, see TYPES mailing list.

We can abstract over these strategies and define our language as a
second-order generalised algebraic theory
\cite{DBLP:journals/corr/abs-1904-04097}, but to state initiality of
our syntax, at some point we need to turn it into a first-order
algebraic theory \cite{DBLP:conf/fscd/BocquetKS23}.

We conjecture that any SOGAT can be turned into an SSC.

Maybe we can do without the extra type equations, by using assumptions.

Luksa, Thorsten thesis.

\bibliography{b}{}
\bibliographystyle{plain}

\end{document}
